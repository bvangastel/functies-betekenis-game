<!doctype html>
<html lang="nl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Functies - Betekenis: de Game!</title>

    <!-- Tailwind via CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM (UMD builds) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX transformation in the browser (only for demo/testing) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="min-h-screen">
    <div id="root"></div>

    <!-- Application code. Using Babel for in‚Äëbrowser JSX transformation. -->
    <script type="text/babel">
      // Extract React hooks
      const { useState, useEffect, useMemo, useRef } = React;
      /*
       * Framer Motion fallback: if the UMD bundle doesn't expose a global
       * motion object (window.framerMotion or window.Motion), provide a
       * minimal fallback so the app can render without errors. This stub
       * returns a simple <div> for motion.div when framer-motion isn't loaded.
       */
      const fm = window.Motion || window.framerMotion || {};
      const motion = fm.motion || {
        div: ({ children, ...props }) => React.createElement('div', props, children),
      };

      // Accent colour used throughout the UI
      const ACCENT = '#e20074';

      // Dataset for flashcards. Each card describes a term with its type and
      // example text on the back. Types are 'functie', 'betekenis' or 'beide'.
      const RAW_CARDS = [
        { term: 'Gezondheid', type: 'beide', back: `Functie: Sportbeleid om ziekteverzuim te verlagen.\n‚úÖ Minder zorgkosten, fittere bevolking.\n‚ùå Druk tot bewegen, ongelijkheid in toegang.\n\nBetekenis: Iemand die hardloopt om stress kwijt te raken.\n‚úÖ Beter welzijn, meer energie.\n‚ùå Blessures, burn-out.` },
        { term: 'Economisch', type: 'beide', back: `Functie: WK Voetbal met miljardenomzet via tv-rechten en sponsoring.\n‚úÖ Werkgelegenheid, economische groei.\n‚ùå Winst niet bij lokale bevolking, uitbuiting.\n\nBetekenis: Topsporter of trainer die betaald krijgt.\n‚úÖ Persoonlijke financi√´le zekerheid, erkenning.\n‚ùå Grote prestatiedruk, korte loopbaan.` },
        { term: 'Identificatie', type: 'betekenis', back: `Fan voelt zich deel van Feyenoord.\n‚úÖ Gevoel ergens bij te horen.\n‚ùå Hooliganisme, teleurstelling bij verlies.` },
        { term: 'Socialisatie', type: 'beide', back: `Functie: Sportverenigingen leren kinderen discipline en samenwerking.\n‚úÖ Fair play, maatschappelijke waarden.\n‚ùå Drill of conformisme.\n\nBetekenis: Tiener leert via basketbal zelfvertrouwen en teamwork.\n‚úÖ Versterkt persoonlijkheid en vaardigheden.\n‚ùå Risico op agressie of deviant gedrag.` },
        { term: 'Democratisering', type: 'functie', back: `Voetbaltoernooien waar alle kinderen mogen meedoen.\n‚úÖ Gelijke kansen, toegankelijkheid.\n‚ùå Financi√´le/culturele drempels blijven.` },
        { term: 'Distinctie', type: 'betekenis', back: `Golf of polo als elitesport.\n‚úÖ Status tonen, eigen smaak benadrukken.\n‚ùå Klassenverschillen, uitsluiting.` },
        { term: 'Herstel', type: 'betekenis', back: `Recreatief zwemmen na werk.\n‚úÖ Stressvermindering, ontspanning.\n‚ùå Soms geen effect, of nieuwe vermoeidheid.` },
        { term: 'Identiteit', type: 'betekenis', back: `Scheidsrechter die identiteit ontleent aan zijn rol.\n‚úÖ Duidelijk zelfbeeld, erkenning.\n‚ùå Chauvinisme of verlies van rol na carri√®re.` },
        { term: 'Interactie', type: 'betekenis', back: `Ouderen die lid blijven van een tennisvereniging.\n‚úÖ Sociaal netwerk, vriendschappen.\n‚ùå Conflicten of rivaliteit.` },
        { term: 'Integratie', type: 'functie', back: `Migrantenjongeren in lokale voetbalclubs.\n‚úÖ Sociale cohesie.\n‚ùå Segregatie of discriminatie mogelijk.` },
        { term: 'Militair', type: 'functie', back: `Sovjet-fitnessprogramma gericht op paraatheid.\n‚úÖ Discipline, fysieke paraatheid.\n‚ùå Instrumentalisering voor militaire doelen.` },
        { term: 'Ontlading (catharsis)', type: 'betekenis', back: `Boksen of spinning om frustraties kwijt te raken.\n‚úÖ Minder stress en spanning.\n‚ùå Agressie kan toenemen bij frustratie/verlies.` },
        { term: 'Ontspanning', type: 'betekenis', back: `Kijken naar de Tour de France.\n‚úÖ Ontsnapping, vermaak.\n‚ùå Commercieel spektakel, oppervlakkigheid.` },
        { term: 'Ontwikkeling / zelfontplooiing', type: 'betekenis', back: `Aikido als pad naar zelfdiscipline en zelfkennis.\n‚úÖ Zelfvertrouwen, morele vorming.\n‚ùå Machogedrag of afhankelijkheid van autoritaire trainers.` },
        { term: 'Plezier / hedonisme', type: 'betekenis', back: `Voetballen op straat met vrienden puur voor de lol.\n‚úÖ Genot, humor, speelsheid.\n‚ùå Overmatig escapisme, vrijblijvendheid.` },
        { term: 'Maatschappelijke controle', type: 'functie', back: `Gemeente investeert in sportclubs om jeugd van straat te houden.\n‚úÖ Ordescheppend, voorkomt criminaliteit.\n‚ùå Repressief of instrumenteel ingezet.` },
        { term: 'Politiek', type: 'functie', back: `Olympische Spelen 1936 als propaganda.\n‚úÖ Diplomatiek/ideologisch instrument.\n‚ùå Misbruik voor politieke doeleinden.` },
        { term: 'Reproductie van ideologie', type: 'functie', back: `Olympisch vuur, vlagceremonies.\n‚úÖ Nationale eenheid en waarden.\n‚ùå Bevestigt nationalisme of ongelijkheid.` },
        { term: 'Reproductie van klassenverhoudingen', type: 'functie', back: `Skyboxen in stadions.\n‚úÖ Zichtbaarheid van doelgroepen (marketing).\n‚ùå Vergroten van ongelijkheid.` },
        { term: 'Reproductie van sekseverhoudingen', type: 'functie', back: `Vrouwenvoetbal minder media-aandacht.\n‚úÖ Kansen voor female empowerment.\n‚ùå Sekseongelijkheid, risico op misbruik.` },
        { term: 'Status', type: 'betekenis', back: `High school quarterback met hoge populariteit.\n‚úÖ Prestige, sociale erkenning.\n‚ùå Uitsluiting van minder getalenteerden.` },
        { term: 'Sociale mobiliteit', type: 'functie', back: `Arme voetballer wordt prof in Europa.\n‚úÖ Opwaartse sociale stijging.\n‚ùå Vaak mythe; succes tijdelijk/uitzonderlijk.` },
        { term: 'Taal (lingu√Østisch)', type: 'functie', back: `Media: "Politiek is topsport".\n‚úÖ Gemeenschappelijke codes, communicatie.\n‚ùå Clich√©s, simplificatie.` },
        { term: 'Vervreemding', type: 'functie', back: `Turnsters onder zware druk vanaf jonge leeftijd.\n‚úÖ Topsportprestaties mogelijk.\n‚ùå Verlies autonomie, vervreemding van lichaam.` },
      ];

      // Mapping of types to display labels and order for challenge selection
      const TYPE_LABELS = { functie: 'Functie', betekenis: 'Betekenis', beide: 'Beide' };
      const TYPE_ORDER = ['functie', 'betekenis', 'beide'];

      // Utility: shuffle an array (Fisher-Yates)
      function shuffle(arr) {
        const a = [...arr];
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      // Quick lookup of card types by term
      const CARD_TYPE_MAP = Object.fromEntries(RAW_CARDS.map((c) => [c.term, c.type]));

      /*
       * Sound effects using the Web Audio API. This hook returns small functions
       * to play sounds for correct, wrong, flip and shuffle actions. If the
       * environment doesn't support AudioContext (e.g. older browsers), the
       * functions will simply no‚Äëop.
       */
      function useSounds() {
        const ctxRef = useRef(null);
        function ensureCtx() {
          if (!ctxRef.current) {
            try {
              ctxRef.current = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
              // If AudioContext cannot be created, stub out the context
              ctxRef.current = { createOscillator: () => ({ connect: () => {}, start: () => {}, stop: () => {}, type: '', frequency: { value: 0 } }),
                                 createGain: () => ({ connect: () => {}, gain: { value: 0 } }),
                                 currentTime: 0,
                               };
            }
          }
          return ctxRef.current;
        }
        function beep({ freq = 660, duration = 0.12, type = 'sine', vol = 0.05 } = {}) {
          const ctx = ensureCtx();
          if (!ctx.createOscillator) return;
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = vol;
          o.connect(g);
          g.connect(ctx.destination);
          o.start();
          o.stop(ctx.currentTime + duration);
        }
        return {
          correct: () => {
            beep({ freq: 880, type: 'triangle' });
            setTimeout(() => beep({ freq: 1320, type: 'triangle' }), 90);
          },
          wrong: () => {
            beep({ freq: 200, type: 'sawtooth' });
          },
          flip: () => {
            beep({ freq: 520, type: 'square', duration: 0.07 });
          },
          shuffle: () => {
            beep({ freq: 660, type: 'sine', duration: 0.06 });
            beep({ freq: 740, duration: 0.06 });
            beep({ freq: 820, duration: 0.06 });
          },
        };
      }

      // UI component: Button with optional selected state and dark mode styling
      const Btn = ({ children, className = '', dark = false, selected = false, style, ...props }) => {
        const base = dark
          ? 'rounded-xl border-2 border-white/20 bg-neutral-800 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-neutral-700 active:scale-[0.98] transition'
          : 'rounded-xl border-2 border-black bg-white px-4 py-2 text-sm font-medium text-black shadow-sm hover:bg-fuchsia-50 active:scale-[0.98] transition';
        const selStyle = selected ? { backgroundColor: ACCENT, borderColor: ACCENT, color: '#ffffff' } : {};
        return (
          <button {...props} style={{ ...(style || {}), ...selStyle }} className={`${base} ${className}`}>
            {children}
          </button>
        );
      };

      // UI component: Statistic display
      const Stat = ({ label, value, dark = false }) => (
        <div className={`rounded-xl px-3 py-2 text-center shadow-sm ${dark ? 'border border-white/15 bg-neutral-900 text-white' : 'border border-fuchsia-200 bg-white text-black'}`}>
          <div className={`text-[10px] uppercase tracking-wide ${dark ? 'text-gray-300' : 'text-gray-500'}`}>{label}</div>
          <div className="text-xl font-semibold">{value}</div>
        </div>
      );

      // Card component: displays term on front and info on back with flip animation.
      // Instead of using Framer Motion, we apply CSS transform and transition directly.
      function Card({ card, flipped, onFlip, feedback, dark = false }) {
        // Compute the rotate transform depending on flipped state
        const rotateY = flipped ? 'rotateY(180deg)' : 'rotateY(0deg)';
        return (
          <div className="relative mx-auto w-full max-w-md select-none" style={{ perspective: '1200px' }}>
            <div
              className="relative h-56 w-full cursor-pointer sm:h-64"
              onClick={onFlip}
              // Apply rotation and transition for flipping effect
              style={{ transform: rotateY, transition: 'transform 0.5s', transformStyle: 'preserve-3d' }}
            >
              {/* Front of card */}
              <div
                className={`absolute inset-0 flex items-center justify-center rounded-2xl border-2 text-center shadow-xl ${dark ? 'border-white/20 bg-neutral-900 text-white' : 'border-black bg-white text-black'}`}
                style={{ backfaceVisibility: 'hidden' }}
              >
                <h2 className="px-4 text-2xl font-bold sm:text-3xl">{card.term}</h2>
              </div>
              {/* Back of card */}
              <div
                className={`absolute inset-0 rounded-2xl text-left shadow-xl ${dark ? 'border-2 border-white/10' : 'border-2 border-black'}`}
                style={{ transform: 'rotateY(180deg)', backfaceVisibility: 'hidden', backgroundColor: ACCENT }}
              >
                <div className="flex h-full flex-col p-4 text-white">
                  <span className="mb-2 w-fit rounded-full border border-white/50 bg-white/10 px-3 py-1 text-[10px] font-semibold">{TYPE_LABELS[card.type]}</span>
                  <p className="whitespace-pre-wrap text-sm leading-relaxed">{card.back}</p>
                </div>
              </div>
            </div>
            {feedback && (
              <div className={`absolute -bottom-3 left-1/2 -translate-x-1/2 rounded-full px-3 py-1 text-xs text-white shadow ${feedback === 'correct' ? 'bg-green-700' : 'bg-red-700'}`}> 
                {feedback === 'correct' ? '‚úì Goed!' : '‚úó Niet goed'}
              </div>
            )}
          </div>
        );
      }

      // Helper to pick an example sentence from the card's back side
      function pickExample(card) {
        const lines = card.back.split(/\n+/).map((l) => l.trim()).filter(Boolean);
        const line = lines.find((x) => x.startsWith('Functie:')) || lines.find((x) => x.startsWith('Betekenis:')) || lines[0];
        return line.replace(/^Functie:\s*|^Betekenis:\s*/i, '');
      }

      // Parse effects from the card text into positive and negative lists for each layer
      function parseEffects(card) {
        const txt = card.back;
        const out = { functie: { pos: [], neg: [] }, betekenis: { pos: [], neg: [] } };
        // Helper to extract lines for a given segment
        const pushLines = (segment, key) => {
          const lines = segment.split(/\n+/).map((s) => s.trim()).filter(Boolean);
          for (const l of lines) {
            if (l.startsWith('‚úÖ')) out[key].pos.push(l.replace(/^‚úÖ\s*/, ''));
            if (l.startsWith('‚ùå')) out[key].neg.push(l.replace(/^‚ùå\s*/, ''));
          }
        };
        const hasFunctie = /(^|\n)Functie:/i.test(txt);
        const hasBetekenis = /(^|\n)Betekenis:/i.test(txt);
        if (hasFunctie || hasBetekenis) {
          const funMatch = txt.split(/Betekenis:/i)[0];
          const betSegment = txt.split(/Betekenis:/i)[1];
          if (/Functie:/i.test(funMatch)) pushLines(funMatch.split(/Functie:/i)[1], 'functie');
          if (betSegment !== undefined) pushLines(betSegment, 'betekenis');
        } else {
          const key = card.type === 'functie' ? 'functie' : 'betekenis';
          pushLines(txt, key);
        }
        return out;
      }

      // Decide which layer to quiz on for challenge 3
      function pickLayerForQuestion(card, eff) {
        if (eff.functie.pos.length && eff.functie.neg.length && eff.betekenis.pos.length && eff.betekenis.neg.length) {
          return Math.random() < 0.5 ? 'functie' : 'betekenis';
        }
        if (eff[card.type]?.pos.length && eff[card.type]?.neg.length) return card.type;
        if (eff.functie.pos.length && eff.functie.neg.length) return 'functie';
        return 'betekenis';
      }

      // Collect all effects globally to build distractors
      function collectGlobalEffects(cards) {
        const pool = { functie: { pos: [], neg: [] }, betekenis: { pos: [], neg: [] } };
        for (const c of cards) {
          const e = parseEffects(c);
          pool.functie.pos.push(...e.functie.pos);
          pool.functie.neg.push(...e.functie.neg);
          pool.betekenis.pos.push(...e.betekenis.pos);
          pool.betekenis.neg.push(...e.betekenis.neg);
        }
        return pool;
      }
      const GLOBAL_EFFECTS = collectGlobalEffects(RAW_CARDS);

      // Build a set of options for a given card in challenge 3
      function makeEffectSet(card) {
        const eff = parseEffects(card);
        const layer = pickLayerForQuestion(card, eff);
        const posList = eff[layer].pos;
        const negList = eff[layer].neg;
        const correctPos = posList[Math.floor(Math.random() * posList.length)] || '';
        const correctNeg = negList[Math.floor(Math.random() * negList.length)] || '';
        // Distractors
        const posDistr = shuffle(GLOBAL_EFFECTS[layer].pos.filter((x) => x !== correctPos)).slice(0, 3);
        const negDistr = shuffle(GLOBAL_EFFECTS[layer].neg.filter((x) => x !== correctNeg)).slice(0, 3);
        const posOptions = shuffle([correctPos, ...posDistr]).slice(0, 4);
        const negOptions = shuffle([correctNeg, ...negDistr]).slice(0, 4);
        return { layer, posOptions, negOptions, correctPos, correctNeg };
      }

      // Round size for sorting game (challenge 4)
      const ROUND_SIZE_4 = 6;
      function initBoard4(sampleTerms) {
        return { pool: sampleTerms, functie: [], betekenis: [], beide: [] };
      }

      // Main application component
      function App() {
        const sounds = useSounds();
        const [mode, setMode] = useState('home'); // Modes: home, learn, challenge1, challenge2, challenge3, challenge4
        const [orderSeed, setOrderSeed] = useState(0);
        const [isDark, setIsDark] = useState(() => {
          try {
            const saved = window.localStorage.getItem('flashcards_dark');
            if (saved !== null) return saved === '1';
          } catch {}
          const prefers = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
          return !!prefers;
        });

        // Persist dark mode preference
        useEffect(() => {
          try { window.localStorage.setItem('flashcards_dark', isDark ? '1' : '0'); } catch {}
        }, [isDark]);

        // Build deck when orderSeed changes
        const deck = useMemo(() => shuffle(RAW_CARDS), [orderSeed]);
        const [index, setIndex] = useState(0);
        const [flipped, setFlipped] = useState(false);
        const [feedback, setFeedback] = useState(null);

        // Stats for each challenge
        // Challenge 1
        const [score1, setScore1] = useState(0);
        const [attempts1, setAttempts1] = useState(0);
        const [streak1, setStreak1] = useState(0);
        const [best1, setBest1] = useState(0);
        // Challenge 2
        const [score2, setScore2] = useState(0);
        const [attempts2, setAttempts2] = useState(0);
        const [streak2, setStreak2] = useState(0);
        const [best2, setBest2] = useState(0);
        // Challenge 3
        const [score3, setScore3] = useState(0);
        const [attempts3, setAttempts3] = useState(0);
        const [streak3, setStreak3] = useState(0);
        const [best3, setBest3] = useState(0);
        const [effectSet, setEffectSet] = useState(null);
        const [selPos, setSelPos] = useState(null);
        const [selNeg, setSelNeg] = useState(null);
        // Challenge 4
        const [score4, setScore4] = useState(0);
        const [attempts4, setAttempts4] = useState(0);
        const [streak4, setStreak4] = useState(0);
        const [best4, setBest4] = useState(0);
        const [board4, setBoard4] = useState(() => initBoard4([]));
        const [result4, setResult4] = useState(null);

        // Reset states when mode or orderSeed changes
        useEffect(() => {
          setIndex(0);
          setFlipped(false);
          setFeedback(null);
          if (mode === 'challenge3') {
            setEffectSet(makeEffectSet(deck[0]));
            setSelPos(null);
            setSelNeg(null);
          }
          if (mode === 'challenge4') {
            newRound4();
          }
        }, [mode, orderSeed]);

        // Current card reference
        const current = deck[index];
        const nextCard = () => {
          setFeedback(null);
          setFlipped(false);
          setIndex((i) => (i + 1 < deck.length ? i + 1 : 0));
        };

        // Update effect set when current card changes in challenge 3
        useEffect(() => {
          if (mode === 'challenge3' && current) {
            setEffectSet(makeEffectSet(current));
            setSelPos(null);
            setSelNeg(null);
          }
        }, [current, mode]);

        // Learn mode actions
        const doFlip = () => {
          setFlipped((f) => !f);
          sounds.flip();
        };
        const doShuffle = () => {
          setOrderSeed((s) => s + 1);
          setIndex(0);
          setFlipped(false);
          sounds.shuffle();
        };

        // Challenge 1: guess the type
        const answerType = (guess) => {
          const correct = current.type === guess;
          setFeedback(correct ? 'correct' : 'wrong');
          setAttempts1((a) => a + 1);
          if (correct) {
            setScore1((s) => {
              const newScore = s + 1;
              setStreak1((st) => {
                const newStreak = st + 1;
                setBest1((b) => Math.max(b, newStreak));
                return newStreak;
              });
              return newScore;
            });
            sounds.correct();
            setTimeout(() => nextCard(), 650);
          } else {
            setStreak1(0);
            sounds.wrong();
          }
        };

        // Challenge 2: multiple choice (recognise the term)
        const options = useMemo(() => {
          if (!current) return [];
          const others = shuffle(RAW_CARDS.filter((c) => c.term !== current.term)).slice(0, 3).map((c) => c.term);
          return shuffle([current.term, ...others]);
        }, [current]);
        const answerMC = (choice) => {
          const correct = choice === current.term;
          setFeedback(correct ? 'correct' : 'wrong');
          setAttempts2((a) => a + 1);
          if (correct) {
            setScore2((s) => {
              const newScore = s + 1;
              setStreak2((st) => {
                const newStreak = st + 1;
                setBest2((b) => Math.max(b, newStreak));
                return newStreak;
              });
              return newScore;
            });
            sounds.correct();
            setTimeout(() => nextCard(), 650);
          } else {
            setStreak2(0);
            sounds.wrong();
          }
        };

        // Challenge 3: select positive and negative effects
        const submitEffects = () => {
          if (!effectSet || selPos === null || selNeg === null) return;
          const correct = effectSet.posOptions[selPos] === effectSet.correctPos && effectSet.negOptions[selNeg] === effectSet.correctNeg;
          setFeedback(correct ? 'correct' : 'wrong');
          setAttempts3((a) => a + 1);
          if (correct) {
            setScore3((s) => {
              const newScore = s + 1;
              setStreak3((st) => {
                const newStreak = st + 1;
                setBest3((b) => Math.max(b, newStreak));
                return newStreak;
              });
              return newScore;
            });
            sounds.correct();
            setTimeout(() => nextCard(), 650);
          } else {
            setStreak3(0);
            sounds.wrong();
          }
        };

        // Challenge 4: sorting game
        function newRound4() {
          const sample = shuffle(RAW_CARDS).slice(0, ROUND_SIZE_4).map((c) => c.term);
          setBoard4(initBoard4(sample));
          setResult4(null);
        }
        function moveTerm(term, dest) {
          setBoard4((b) => {
            const nb = { pool: [], functie: [], betekenis: [], beide: [] };
            for (const k of Object.keys(nb)) {
              nb[k] = b[k].filter((t) => t !== term);
            }
            if (dest && nb[dest]) nb[dest] = [...nb[dest], term]; else nb.pool = [...nb.pool, term];
            return nb;
          });
        }
        function cycleDestOf(term) {
          const keys = ['pool', ...TYPE_ORDER];
          const where = keys.find((k) => board4[k].includes(term));
          const idx = keys.indexOf(where);
          const next = keys[(idx + 1) % keys.length];
          moveTerm(term, next === 'pool' ? null : next);
        }
        function onDropFactory(dest) {
          return (e) => {
            e.preventDefault();
            const term = e.dataTransfer.getData('text/plain');
            moveTerm(term, dest);
          };
        }
        function checkSort() {
          const placed = [...board4.functie, ...board4.betekenis, ...board4.beide];
          const total = board4.pool.length + placed.length;
          let correctCount = 0;
          for (const t of board4.functie) if (CARD_TYPE_MAP[t] === 'functie') correctCount++;
          for (const t of board4.betekenis) if (CARD_TYPE_MAP[t] === 'betekenis') correctCount++;
          for (const t of board4.beide) if (CARD_TYPE_MAP[t] === 'beide') correctCount++;
          setScore4((s) => s + correctCount);
          setAttempts4((a) => a + 1);
          const allPlaced = board4.pool.length === 0;
          const perfect = allPlaced && correctCount === total;
          setResult4(`${correctCount}/${total} correct${allPlaced ? ' (alles geplaatst)' : ' (nog niet alles geplaatst)'}`);
          if (perfect) {
            setStreak4((st) => {
              const newStreak = st + 1;
              setBest4((b) => Math.max(b, newStreak));
              return newStreak;
            });
            sounds.correct();
            setTimeout(() => newRound4(), 900);
          } else {
            setStreak4(0);
            sounds.wrong();
          }
        }

        // Zone component for challenge 4
        function Zone({ title, items, onDrop, dark }) {
          return (
            <div
              onDragOver={(e) => e.preventDefault()}
              onDrop={onDrop}
              className={`min-h-[140px] rounded-2xl border-2 p-3 shadow ${dark ? 'border-white/20 bg-neutral-900 text-white' : 'border-black bg-white text-black'}`}
            >
              <div className="mb-2 text-xs font-semibold opacity-80">{title}</div>
              <div className="flex flex-wrap gap-2">
                {items.map((t) => (
                  <button
                    key={t}
                    draggable
                    onDragStart={(e) => e.dataTransfer.setData('text/plain', t)}
                    onClick={() => cycleDestOf(t)}
                    className={`select-none rounded-xl border px-2 py-1 text-xs shadow ${dark ? 'border-white/15 bg-neutral-800 text-white' : 'border-black bg-white text-black'}`}
                    title="Klik om te verplaatsen / sleep naar een vak"
                  >
                    {t}
                  </button>
                ))}
              </div>
            </div>
          );
        }

        // Stats bar component: shows different stats depending on mode
        function StatsBar() {
          if (mode === 'challenge1') {
            return (
              <section className="mb-4 grid grid-cols-4 gap-2 sm:gap-3">
                <Stat label="Score" value={score1} dark={isDark} />
                <Stat label="Pogingen" value={attempts1} dark={isDark} />
                <Stat label="Streak" value={streak1} dark={isDark} />
                <Stat label="Best" value={best1} dark={isDark} />
              </section>
            );
          }
          if (mode === 'challenge2') {
            return (
              <section className="mb-4 grid grid-cols-4 gap-2 sm:gap-3">
                <Stat label="Score" value={score2} dark={isDark} />
                <Stat label="Pogingen" value={attempts2} dark={isDark} />
                <Stat label="Streak" value={streak2} dark={isDark} />
                <Stat label="Best" value={best2} dark={isDark} />
              </section>
            );
          }
          if (mode === 'challenge3') {
            return (
              <section className="mb-4 grid grid-cols-4 gap-2 sm:gap-3">
                <Stat label="Score" value={score3} dark={isDark} />
                <Stat label="Pogingen" value={attempts3} dark={isDark} />
                <Stat label="Streak" value={streak3} dark={isDark} />
                <Stat label="Best" value={best3} dark={isDark} />
              </section>
            );
          }
          if (mode === 'challenge4') {
            return (
              <section className="mb-4 grid grid-cols-4 gap-2 sm:gap-3">
                <Stat label="Score" value={score4} dark={isDark} />
                <Stat label="Pogingen" value={attempts4} dark={isDark} />
                <Stat label="Streak" value={streak4} dark={isDark} />
                <Stat label="Best" value={best4} dark={isDark} />
              </section>
            );
          }
          if (mode === 'learn') {
            return (
              <section className="mb-4 grid grid-cols-3 gap-2 sm:gap-3">
                <Stat label="Kaarten" value={deck.length} dark={isDark} />
                <Stat label="Index" value={`${index + 1}/${deck.length}`} dark={isDark} />
                <Stat label="Mode" value="Het Trainingsveld" dark={isDark} />
              </section>
            );
          }
          return null;
        }

        // Header with navigation buttons
        function HeaderTabs() {
          return (
            <div className="flex items-center gap-1 sm:gap-2">
              <Btn onClick={() => setMode('home')} selected={mode === 'home'} dark={isDark}>Het Clubhuis</Btn>
              <Btn onClick={() => setMode('learn')} selected={mode === 'learn'} dark={isDark}>Het Trainingsveld</Btn>
              <Btn onClick={() => setMode('challenge1')} selected={mode === 'challenge1'} dark={isDark}>Wedstrijd 1</Btn>
              <Btn onClick={() => setMode('challenge2')} selected={mode === 'challenge2'} dark={isDark}>Wedstrijd 2</Btn>
              <Btn onClick={() => setMode('challenge3')} selected={mode === 'challenge3'} dark={isDark}>Wedstrijd 3</Btn>
              <Btn onClick={() => setMode('challenge4')} selected={mode === 'challenge4'} dark={isDark}>Wedstrijd 4</Btn>
              <Btn onClick={() => setIsDark((d) => !d)} dark={isDark} aria-label="Toggle dark mode">{isDark ? '‚òÄÔ∏è' : 'üåô'}</Btn>
            </div>
          );
        }

        // Home screen component with navigation to learn and challenges
        function Home() {
          return (
            <div className="grid gap-3 sm:grid-cols-2">
              <div className={`rounded-2xl border-2 p-5 shadow ${isDark ? 'border-white/20 bg-neutral-900 text-white' : 'border-black bg-white text-black'}`}>
                <h2 className="text-xl font-bold">Het Trainingsveld</h2>
                <p className="mt-1 text-sm opacity-80">Train je kennis: bekijk kaarten, flip voor uitleg en schud het deck.</p>
                <Btn className="mt-3" onClick={() => setMode('learn')} selected={true} dark={isDark}>
                  Naar het Trainingsveld
                </Btn>
              </div>
              <div className={`rounded-2xl border-2 p-5 shadow ${isDark ? 'border-white/20 bg-neutral-900 text-white' : 'border-black bg-white text-black'}`}>
                <h2 className="text-xl font-bold">Wedstrijden</h2>
                <div className="mt-2 grid gap-2">
                  <Btn onClick={() => setMode('challenge1')} dark={isDark}>Wedstrijd 1 ‚Äì Type kiezen</Btn>
                  <Btn onClick={() => setMode('challenge2')} dark={isDark}>Wedstrijd 2 ‚Äì Herken de term</Btn>
                  <Btn onClick={() => setMode('challenge3')} dark={isDark}>Wedstrijd 3 ‚Äì Kies de effecten</Btn>
                  <Btn onClick={() => setMode('challenge4')} dark={isDark}>Wedstrijd 4 ‚Äì Sorteren (sleep)</Btn>
                </div>
              </div>
            </div>
          );
        }

        // Render UI based on current mode
        return (
          <div className={`min-h-screen p-4 sm:p-6 ${isDark ? 'bg-gradient-to-b from-neutral-900 to-black text-white' : 'bg-gradient-to-b from-fuchsia-50 to-white text-black'}`}>
            <div className="mx-auto w-full max-w-screen-sm sm:max-w-2xl">
              {/* Header */}
              <header className="mb-4 flex items-center justify-between gap-2">
                <h1 className={`font-bold ${isDark ? 'text-white' : 'text-black'} text-lg sm:text-2xl`}>
                  Functies - Betekenis: de Game!
                </h1>
                <HeaderTabs />
              </header>
              <StatsBar />
              {mode === 'home' && <Home />}
              {mode === 'learn' && current && (
                <>
                  <Card card={current} flipped={flipped} onFlip={doFlip} feedback={feedback} dark={isDark} />
                  <div className="sticky bottom-2 mt-4 flex w-full justify-center gap-2">
                    <Btn onClick={doFlip} dark={isDark}>Flip</Btn>
                    <Btn onClick={nextCard} dark={isDark}>Volgende</Btn>
                    <Btn onClick={doShuffle} dark={isDark}>Schudden</Btn>
                  </div>
                </>
              )}
              {mode === 'challenge1' && current && (
                <>
                  <Card card={current} flipped={flipped} onFlip={doFlip} feedback={feedback} dark={isDark} />
                  <div className="sticky bottom-2 mt-4 grid w-full grid-cols-3 gap-2">
                    {TYPE_ORDER.map((t) => (
                      <Btn key={t} onClick={() => answerType(t)} dark={isDark}>{TYPE_LABELS[t]}</Btn>
                    ))}
                  </div>
                </>
              )}
              {mode === 'challenge2' && current && (
                <div className="mx-auto mt-2 w-full max-w-xl">
                  <div className={`rounded-2xl border-2 p-4 shadow ${isDark ? 'border-white/20 bg-neutral-900' : 'border-black bg-white'}`}>
                    <div className={`text-xs ${isDark ? 'text-gray-300' : 'text-gray-700'}`}>Voorbeeld uit sport</div>
                    <div className={`mt-1 font-semibold sm:text-lg ${isDark ? 'text-white text-base' : 'text-black text-base'}`}>{pickExample(current)}</div>
                  </div>
                  <div className="mt-4 grid grid-cols-1 gap-2 sm:grid-cols-2">
                    {options.map((opt) => (
                      <Btn key={opt} onClick={() => answerMC(opt)} className="text-left" dark={isDark}>{opt}</Btn>
                    ))}
                  </div>
                  {feedback && (
                    <div className={`mt-3 w-full rounded-xl px-3 py-2 text-center text-sm text-white ${feedback === 'correct' ? 'bg-green-700' : 'bg-red-700'}`}>
                      {feedback === 'correct' ? '‚úì Goed!' : '‚úó Niet goed ‚Äî probeer opnieuw'}
                    </div>
                  )}
                </div>
              )}
              {mode === 'challenge3' && current && effectSet && (
                <div className="mx-auto mt-2 w-full max-w-2xl">
                  <div className={`rounded-2xl border-2 p-4 shadow ${isDark ? 'border-white/20 bg-neutral-900' : 'border-black bg-white'}`}>
                    <div className="text-xs opacity-80">
                      Kies 1 <b>positief</b> en 1 <b>negatief</b> effect voor <b>{current.term}</b> ‚Äî <b>{TYPE_LABELS[effectSet.layer]}</b>
                    </div>
                  </div>
                  <div className="mt-4 grid grid-cols-1 gap-3 sm:grid-cols-2">
                    <div className={`rounded-2xl border-2 p-3 shadow ${isDark ? 'border-white/20 bg-neutral-900' : 'border-black bg-white'}`}>
                      <div className="mb-2 text-xs font-semibold">Positieve effecten</div>
                      <div className="grid gap-2">
                        {effectSet.posOptions.map((opt, i) => (
                          <Btn key={i} onClick={() => setSelPos(i)} selected={selPos === i} className="text-left" dark={isDark}>{opt}</Btn>
                        ))}
                      </div>
                    </div>
                    <div className={`rounded-2xl border-2 p-3 shadow ${isDark ? 'border-white/20 bg-neutral-900' : 'border-black bg-white'}`}>
                      <div className="mb-2 text-xs font-semibold">Negatieve effecten</div>
                      <div className="grid gap-2">
                        {effectSet.negOptions.map((opt, i) => (
                          <Btn key={i} onClick={() => setSelNeg(i)} selected={selNeg === i} className="text-left" dark={isDark}>{opt}</Btn>
                        ))}
                      </div>
                    </div>
                  </div>
                  <div className="mt-3 flex items-center gap-2">
                    <Btn onClick={submitEffects} dark={isDark} disabled={selPos == null || selNeg == null} style={{ opacity: selPos == null || selNeg == null ? 0.6 : 1 }}>Bevestig</Btn>
                    <Btn onClick={() => { setEffectSet(makeEffectSet(current)); setSelPos(null); setSelNeg(null); setFeedback(null); }} dark={isDark}>Andere opties</Btn>
                  </div>
                  {feedback && (
                    <div className={`mt-3 w-full rounded-xl px-3 py-2 text-center text-sm text-white ${feedback === 'correct' ? 'bg-green-700' : 'bg-red-700'}`}>
                      {feedback === 'correct' ? '‚úì Goed!' : `‚úó Niet goed ‚Äî juiste: + ${effectSet.correctPos} / ‚àí ${effectSet.correctNeg}`}
                    </div>
                  )}
                </div>
              )}
              {mode === 'challenge4' && (
                <div className="mx-auto mt-2 w-full max-w-3xl">
                  <div className="mb-3 flex flex-wrap items-center gap-2">
                    <Btn onClick={newRound4} dark={isDark}>Nieuwe set</Btn>
                    <Btn onClick={checkSort} dark={isDark}>Check antwoorden</Btn>
                    {result4 && (
                      <span className={`rounded-xl px-3 py-2 text-sm ${isDark ? 'bg-neutral-800 text-white' : 'bg-neutral-100 text-black'}`}>{result4}</span>
                    )}
                  </div>
                  <div className="grid grid-cols-1 gap-3 sm:grid-cols-2 lg:grid-cols-4">
                    <Zone title="Nog te plaatsen" items={board4.pool} onDrop={onDropFactory(null)} dark={isDark} />
                    <Zone title="Functie" items={board4.functie} onDrop={onDropFactory('functie')} dark={isDark} />
                    <Zone title="Betekenis" items={board4.betekenis} onDrop={onDropFactory('betekenis')} dark={isDark} />
                    <Zone title="Beide" items={board4.beide} onDrop={onDropFactory('beide')} dark={isDark} />
                  </div>
                  <div className={`mt-2 text-xs ${isDark ? 'text-gray-400' : 'text-gray-600'}`}>
                    Tip: Sleep termen naar de juiste vakken of klik op een term om door de vakken te cyclen.
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      }

      // Kick off the React application
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>